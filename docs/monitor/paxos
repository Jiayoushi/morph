Monitor implemented a simple multi-paxos to provide a consistent view of the object store
cluster map which is used to do consistent hashing.

When an oss (object store server) wants to add itself to the monitor, it invokes the AddOss
RPC. The monitor will ask paxos to replicate this command before applying it. Only the leader
monitor can propose values to the paxos, which avoids the paxos livelock problem.

A leader is picked by an implicit rule: the server that is alive and with the highest id is
the current leader. Every monitor is sending out hearbeats to let others know they are alive. 
This can be costly only if the number of monitors is too much. 

When paxos starts on a value, it will first check if there is any log that is accepted 
but not yet chosen. If so, Morph's paxos will propose that value first, which makes the 
changes of oss cluster monotonically (it's not possible for the cluster change to go 
from config#0 to config#2 without going to #1 first). After paxos gets a log index that 
has no previous accepted value, paxos sets that log entry to accepted with the given value
and starts proposing to all acceptors. After the majority replies, it checks if there is 
any value already accepted, if so, it will use that value instead. Then, the paxos will
send Commit RPC to all acceptors to commit the value and wait for a majority of responses.
Only if no acceptors from the majority has a larger min_proposal is the value considered
to be chosen.

Log compaction, client protocol and cluster membership change of the monitor cluster itself 
and so on are not yet implemented. The two-phase approach can be optimized into one as well.


Replication:
   Keep sending Accept RPC until leader and other servers have identical first_unchosen_index.

Q: When should a server starts sending out Accept to replicate chosen entries if it thinks
   it's the leader?
A: What happens if the server starts right away? If it knows the entry is chosen, it sends
   out Accept. And everything goes well. Even if an entry is previously chosen, and this
   server does not know, it's okay. Since it will do a two-phase only to chosen the same
   value again. If it does not, what is it waiting for? 

Q: What if leader A is the only one that knows an entry has been chosen and now is down?
A: It's okay.
   The leader B comes along and try to prepare another value. Suppose it does not know the
   value before, it will try to issue its own value. It will discover a value has already been
   accpeted so he will use that value instead. And finally the value will be chosen again.

Q: If there is a prepare request coming from a server that the local server belives is not the 
   leader, is it safe to ignore the request?
A: It's okay and required. 
   Suppose a server B lost connection to the leader A, then it think it's the leader and 
   proceed to do prepare. Other servers still have the connection to the leader A, if they
   do not reject the request, leader B's prepare requests will go through, and then leader A's
   request will come right afterwards. This is livelock situation we want to solve in the first
   place, so we need to turn down requests coming from leaders that is not considered to be
   the leader.

Q: If there is an Accept request coming from a server that the local server belives is not the
   leader, is it safe to ignore the request?
A: It's okay and required.
   There are two types of accept requests, one is to replicate the chosen entries. Another one
   is to ask other servers to accept. 
   Let's fisrt analyze the first type of Accept. It's better to not turn down the accept because
   since it's chosen, its proposal number will be +INFINITY, and its value can definitely
   be used. But what if we turn it down? Will the new leader send the same accept? Yes. But the
   new leader may not know the value is chosen, then it will do a two-phase commit. Only after
   the two-phase completes will the same accept ever be sent again. So it's again better to not
   turn down the request.
   Let's now analyze the second type of Accept. If we receive an accept from a server A that we
   do not think is the leader, we should just turn it down. If we think server D is the leader,
   and we have a (A, B, C) (D, E) network partition. It's okay for D, E to turn down the Accept,
   since ABC will still form a quorum. If network is good other than A lose connection to D,
   it's still okay to turn down. It's always safe to turn down. What if we let the Accept through? 
   It's okay. It will only be a problem if leader D now issue a prepare request to change the
   value of min_proposal. Then livelock may arise. So we need to turn it down!
